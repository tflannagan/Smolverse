<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smolverse | Ty</title>
    <link rel="icon" type="image/png" href="favicon.ico">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Quicksand:wght@300..700&display=swap" rel="stylesheet">
   
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: "Quicksand", sans-serif !important;
            touch-action: none;
        }

        body {
            background: #1a1a1a;
            color: #ffffff;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 10px;
            overflow: hidden;
        }

        .simulator {
            width: 100%;
            height: 100vh;
            max-height: 96vh;
            background: #2a2a2a;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            display: grid;
            grid-template-columns: 1fr auto;
            padding: 10px;
            gap: 10px;
            position: relative;
        }

        .viewport-container {
            position: relative;
            background: #000;
            border-radius: 20px;
            overflow: hidden;
            box-shadow: inset 0 0 100px rgba(0,0,0,0.8);
        }

        .viewport {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    border-radius: 20px;
    overflow: hidden;
    background: #000;
}

        #simulatorCanvas {
            width: 100%;
            height: 100%;
            background: #000;
            touch-action: none;
        }

        .controls {
            background: #222;
            border-radius: 15px;
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            height: 100%;
            min-width: 70px;
        }

        .control-group {
            background: #2a2a2a;
            border-radius: 12px;
            padding: 10px;
            display: flex;
            flex-direction: column;
        }

        .particle-controls {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .particle-button {
            padding: 12px;
            background: #333;
            border: none;
            color: #fff;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            -webkit-tap-highlight-color: transparent;
        }

        .particle-button:hover {
            background: #444;
        }

        .particle-button:active {
            transform: scale(0.95);
        }

        .action-buttons {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .action-button {
            padding: 9px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.2s;
            -webkit-tap-highlight-color: transparent;
        }

        .start-button {
            background: #333333;
            color: white;
        }

        .start-button:hover {
            background: #444;
        }

        .clear-button {
            background: #333333;
            color: white;
        }

        .clear-button:hover {
            background: #b32d00;
        }

        .mini-map {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 150px;
            height: 150px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #333;
            border-radius: 8px;
            pointer-events: none;
        }

        .celestial-toggle-button {
            background: #333333;
            color: white;
            transition: all 0.2s ease;
        }
        
        .celestial-toggle-button:hover {
            background: #444;
        }
        
        .celestial-toggle-button.disabled {
            background: #222;
        }
        
        .celestial-toggle-button.disabled:hover {
            background: #2a2a2a;
        }

        .minimap-toggle-button {
            background: #333333;
            color: white;
            transition: all 0.2s ease;
        }
        
        .minimap-toggle-button:hover {
            background: #444;
        }
        
        .minimap-toggle-button.disabled {
            background: #222;
        }
        
        .minimap-toggle-button.disabled:hover {
            background: #2a2a2a;
        }
    
        .mini-map.hidden {
            display: none;
        }

        @media (max-width: 768px) {
            .simulator {
                grid-template-columns: 1fr;
                grid-template-rows: 1fr auto;
                height: 100vh;
                max-height: -webkit-fill-available;
                padding: 8px;
                gap: 8px;
            }

            .controls {
                flex-direction: row;
                justify-content: space-between;
                height: auto;
                padding: 8px;
                position: fixed;
                bottom: 0px;
                left: 10px;
                right: 10px;
                z-index: 1000;
                background: rgba(34, 34, 34, 0.9);
                
                -webkit-backdrop-filter: blur(10px);
                backdrop-filter: blur(10px);
            }

            .control-group {
                flex: 1;
                margin: 0 4px;
                padding: 8px;
            }

            .particle-controls {
                flex-direction: row;
                justify-content: space-around;
            }

            .action-buttons {
                flex-direction: row;
                justify-content: space-around;
            }

            .particle-button {
                padding: 8px;
                flex: 1;
                margin: 0 4px;
            }

            .action-button {
                padding: 8px;
                flex: 1;
                margin: 0 4px;
            }

            .mini-map {
                display: none;
            }

            .particle-button svg,
            .action-button svg {
                width: 16px;
                height: 16px;
            }
        }

        @media (max-height: 600px) and (orientation: landscape) {
            .controls {
                padding: 4px;
            }

            .control-group {
                padding: 4px;
            }

            .particle-button,
            .action-button {
                padding: 6px;
            }

            .particle-button svg,
            .action-button svg {
                width: 14px;
                height: 14px;
            }
        }
    </style>
</head>
<body>
    <div class="simulator">
        <div class="viewport-container">
            <div class="viewport">
                <canvas id="simulatorCanvas"></canvas>
            </div>
            <canvas id="miniMap" class="mini-map"></canvas>
        </div>
        <div class="controls">
            <div class="control-group">
                <div class="particle-controls">
                    <button class="particle-button" id="addProton"><svg xmlns="http://www.w3.org/2000/svg" height="20px" viewBox="0 -960 960 960" width="20px" fill="#fff"><path d="M444-288h72v-156h156v-72H516v-156h-72v156H288v72h156v156Zm36.28 192Q401-96 331-126t-122.5-82.5Q156-261 126-330.96t-30-149.5Q96-560 126-629.5q30-69.5 82.5-122T330.96-834q69.96-30 149.5-30t149.04 30q69.5 30 122 82.5T834-629.28q30 69.73 30 149Q864-401 834-331t-82.5 122.5Q699-156 629.28-126q-69.73 30-149 30Zm-.28-72q130 0 221-91t91-221q0-130-91-221t-221-91q-130 0-221 91t-91 221q0 130 91 221t221 91Zm0-312Z"/></svg></button>
                    <button class="particle-button" id="addNeutron"><svg xmlns="http://www.w3.org/2000/svg" height="20px" viewBox="0 -960 960 960" width="20px" fill="#fff"><path d="M480-240q100 0 170-70t70-170q0-100-70-170t-170-70q-100 0-170 70t-70 170q0 100 70 170t170 70Zm-96-204v-72h192v72H384Zm96.28 348Q401-96 331-126t-122.5-82.5Q156-261 126-330.96t-30-149.5Q96-560 126-629.5q30-69.5 82.5-122T330.96-834q69.96-30 149.5-30t149.04 30q69.5 30 122 82.5T834-629.28q30 69.73 30 149Q864-401 834-331t-82.5 122.5Q699-156 629.28-126q-69.73 30-149 30Zm-.28-72q130 0 221-91t91-221q0-130-91-221t-221-91q-130 0-221 91t-91 221q0 130 91 221t221 91Zm0-312Z"/></svg></button>
                    <button class="particle-button" id="addElectron"><svg xmlns="http://www.w3.org/2000/svg" height="20px" viewBox="0 -960 960 960" width="20px" fill="#fff"><path d="M232-444v-72h496v72H232Z"/></svg></button>
                </div>
            </div>
            <div class="control-group">
                <div class="action-buttons">
                    <button class="action-button celestial-toggle-button" id="toggleCelestialBody">
                        <svg xmlns="http://www.w3.org/2000/svg" height="20px" viewBox="0 -960 960 960" width="24px" fill="currentColor">
                            <path d="M480-360q50 0 85-35t35-85q0-50-35-85t-85-35q-50 0-85 35t-35 85q0 50 35 85t85 35Zm0 60q-75 0-127.5-52.5T300-480q0-75 52.5-127.5T480-660q75 0 127.5 52.5T660-480q0 75-52.5 127.5T480-300Zm0 180q-150 0-255-105T120-480q0-150 105-255t255-105q150 0 255 105t105 255q0 150-105 255T480-120Zm0-360Zm0 280q116 0 198-82t82-198q0-116-82-198t-198-82q-116 0-198 82t-82 198q0 116 82 198t198 82Z"/>
                        </svg>
                    </button>
                    <button class="action-button minimap-toggle-button" id="toggleMinimap">
                        <svg xmlns="http://www.w3.org/2000/svg" height="20px" viewBox="0 0 24 24" width="24px" fill="currentColor">
                            <path d="M3 3h18v18H3V3zm16 16V5H5v14h14zM8 8h8v8H8V8z"/>
                        </svg>
                    </button>
                </div>
            </div>
            <div class="control-group">
                <div class="action-buttons">
                    <button class="action-button start-button" id="toggleAnimation">
                        <svg xmlns="http://www.w3.org/2000/svg" height="20px" viewBox="0 -960 960 960" width="24px" fill="currentColor">
                            <path d="M520-200h80v-560h-80v560Zm-160 0h80v-560h-80v560Z"/>
                        </svg>
                    </button>
                    <button class="action-button clear-button" id="clearCanvas">
                        <svg xmlns="http://www.w3.org/2000/svg" height="20px" viewBox="0 -960 960 960" width="24px" fill="currentColor">
                            <path d="M280-120q-33 0-56.5-23.5T200-200v-520h-40v-80h200v-40h240v40h200v80h-40v520q0 33-23.5 56.5T680-120H280Zm400-600H280v520h400v-520ZM360-280h80v-360h-80v360Zm160 0h80v-360h-80v360ZM280-720v520-520Z"/>
                        </svg>
                    </button>
                </div>
            </div>

        </div>
    </div>

    <script>
       const canvas = document.getElementById('simulatorCanvas');
        const miniMap = document.getElementById('miniMap');
        const ctx = canvas.getContext('2d');
        const miniCtx = miniMap.getContext('2d');

        let WORLD_SIZE = {
                width: 4000,
                height: 4000
            };
        
        const VIEWPORT_SCALE = 1;
        const MIN_ZOOM = 0.05;  
        const MAX_ZOOM = 10;
        const elasticity = 0.9;

        let particles = [];
        let isAnimating = false;
        let cameraX = WORLD_SIZE.width / 2;
        let cameraY = WORLD_SIZE.height / 2;
        let zoom = 1;
        let targetZoom = 1;
        let isDragging = false;
        let lastX = 0;
        let lastY = 0;
        let isMouseDown = false;
        let isRightMouseDown = false;
        let isPanning = false;
        let keys = new Set();
        let zoomSmoothness = 0.1;
        let cameraSmoothness = 0.1;
        let lastUpdateTime = 0;
        let showCelestialBody = true;
        let showMinimap = true;
      
        function resizeCanvas() {
            const viewport = canvas.parentElement;
            canvas.width = viewport.offsetWidth;
            canvas.height = viewport.offsetHeight;
            miniMap.width = 150;
            miniMap.height = 150;
            
            const aspect = canvas.width / canvas.height;
            WORLD_SIZE.width = 4000;
            WORLD_SIZE.height = 4000 / aspect;
            
            celestialBody.updatePosition();
            
            const minZoom = calculateMinZoom();
            zoom = Math.max(zoom, minZoom);
            targetZoom = Math.max(targetZoom, minZoom);
        }
        function calculateMinZoom() {
            const viewportAspect = canvas.width / canvas.height;
            return Math.max(canvas.width / WORLD_SIZE.width, canvas.height / WORLD_SIZE.height);
        }

        function checkBoundaries() {
            const minAllowedZoom = calculateMinZoom();
            zoom = Math.max(minAllowedZoom, Math.min(MAX_ZOOM, zoom));
            targetZoom = Math.max(minAllowedZoom, Math.min(MAX_ZOOM, targetZoom));
            
            const visibleWidth = canvas.width / zoom;
            const visibleHeight = canvas.height / zoom;
            
            const maxX = WORLD_SIZE.width - visibleWidth / 2;
            const maxY = WORLD_SIZE.height - visibleHeight / 2;
            const minX = visibleWidth / 2;
            const minY = visibleHeight / 2;
            
            cameraX = Math.max(minX, Math.min(maxX, cameraX));
            cameraY = Math.max(minY, Math.min(maxY, cameraY));
        }

        function updateCamera() {
            const moveSpeed = 20 / zoom;
            if (keys.has('ArrowLeft') || keys.has('a')) cameraX -= moveSpeed;
            if (keys.has('ArrowRight') || keys.has('d')) cameraX += moveSpeed;
            if (keys.has('ArrowUp') || keys.has('w')) cameraY -= moveSpeed;
            if (keys.has('ArrowDown') || keys.has('s')) cameraY += moveSpeed;

            zoom += (targetZoom - zoom) * zoomSmoothness;
            checkBoundaries();
        }

        function zoomToPoint(x, y, factor) {
            const oldZoom = zoom;
            const newTargetZoom = targetZoom * factor;
            const minAllowedZoom = calculateMinZoom();
            
            targetZoom = Math.max(minAllowedZoom, Math.min(MAX_ZOOM, newTargetZoom));
            
            if (targetZoom !== oldZoom) {
                const worldX = cameraX + (x - canvas.width / 2) / oldZoom;
                const worldY = cameraY + (y - canvas.height / 2) / oldZoom;
                
                const newCameraX = worldX - (x - canvas.width / 2) / targetZoom;
                const newCameraY = worldY - (y - canvas.height / 2) / targetZoom;
                
                cameraX = newCameraX;
                cameraY = newCameraY;
                checkBoundaries();
            }
        }
        
        class CelestialBody {
            constructor(x, y, mass, radius) {
       
                this.mass = mass;
                this.radius = radius;
                this.gForce = 0.05;
                

                this.coronaRadius = radius * 1.5;
                this.fieldRadius = radius * 3;
                
                this.colors = {
                    proton: '#B94FFF',
                    neutron: '#318AFF',
                    electron: '#FF4980' 
                };
                
                this.recentParticles = {
                    proton: 0,
                    neutron: 0,
                    electron: 0
                };
                this.maxTypeCount = 50;
                
                this.updatePosition();
            }
        
            updatePosition() {
                this.x = WORLD_SIZE.width / 2;
                this.y = WORLD_SIZE.height / 2;
            }
        
            draw(ctx, zoom, cameraX, cameraY, canvasWidth, canvasHeight) {
                const screenX = (this.x - cameraX) * zoom + canvasWidth / 2;
                const screenY = (this.y - cameraY) * zoom + canvasHeight / 2;
        
                this.drawField(ctx, screenX, screenY, zoom);
                
                this.drawCorona(ctx, screenX, screenY, zoom);

                this.drawCore(ctx, screenX, screenY, zoom);
            }
        
            drawField(ctx, x, y, zoom) {
                const gradient = ctx.createRadialGradient(
                    x, y, this.radius * zoom,
                    x, y, this.fieldRadius * zoom
                );

                const total = Object.values(this.recentParticles).reduce((a, b) => a + b, 0);
                if (total > 0) {
                    const alpha = Math.min(0.15, total / (this.maxTypeCount * 3) * 0.15);
                    gradient.addColorStop(0, `rgba(150, 150, 255, ${alpha})`);
                    gradient.addColorStop(1, 'rgba(150, 150, 255, 0)');
                } else {
                    gradient.addColorStop(0, 'rgba(150, 150, 255, 0.05)');
                    gradient.addColorStop(1, 'rgba(150, 150, 255, 0)');
                }
        
                ctx.beginPath();
                ctx.arc(x, y, this.fieldRadius * zoom, 0, Math.PI * 2);
                ctx.fillStyle = gradient;
                ctx.fill();
            }
        
            drawCorona(ctx, x, y, zoom) {
                const total = Object.values(this.recentParticles).reduce((a, b) => a + b, 0);
                const gradient = ctx.createRadialGradient(
                    x, y, this.radius * zoom,
                    x, y, this.coronaRadius * zoom
                );
                
                if (total > 0) {
                    const ratios = {
                        proton: this.recentParticles.proton / total,
                        neutron: this.recentParticles.neutron / total,
                        electron: this.recentParticles.electron / total
                    };
        
                    const intensity = Math.min(0.8, total / (this.maxTypeCount * 3) * 0.8);
                    
                    gradient.addColorStop(0, this.blendColors([
                        { color: this.colors.proton, weight: ratios.proton },
                        { color: this.colors.neutron, weight: ratios.neutron },
                        { color: this.colors.electron, weight: ratios.electron }
                    ], intensity));
                    
                    gradient.addColorStop(1, 'rgba(150, 150, 255, 0)');
                } else {
                    gradient.addColorStop(0, 'rgba(150, 150, 255, 0.3)');
                    gradient.addColorStop(1, 'rgba(150, 150, 255, 0)');
                }
        
                ctx.beginPath();
                ctx.arc(x, y, this.coronaRadius * zoom, 0, Math.PI * 2);
                ctx.fillStyle = gradient;
                ctx.fill();
            }
        
            drawCore(ctx, x, y, zoom) {
                const gradient = ctx.createRadialGradient(
                    x, y, 0,
                    x, y, this.radius * zoom
                );
                
                const total = Object.values(this.recentParticles).reduce((a, b) => a + b, 0);
                if (total > 0) {
                    const ratios = {
                        proton: this.recentParticles.proton / total,
                        neutron: this.recentParticles.neutron / total,
                        electron: this.recentParticles.electron / total
                    };
        
                    const coreColor = this.blendColors([
                        { color: this.colors.proton, weight: ratios.proton },
                        { color: this.colors.neutron, weight: ratios.neutron },
                        { color: this.colors.electron, weight: ratios.electron }
                    ], 1);
        
                    gradient.addColorStop(0, coreColor);
                    gradient.addColorStop(0.6, this.adjustColorBrightness(coreColor, -30));
                    gradient.addColorStop(1, this.adjustColorBrightness(coreColor, -50));
                } else {
                    gradient.addColorStop(0, 'rgba(150, 150, 255, 0.8)');
                    gradient.addColorStop(1, 'rgba(100, 100, 200, 0.6)');
                }
        
                ctx.beginPath();
                ctx.arc(x, y, this.radius * zoom, 0, Math.PI * 2);
                ctx.fillStyle = gradient;
                ctx.fill();
            }
        
            blendColors(colors, intensity) {
                let r = 0, g = 0, b = 0;
                colors.forEach(({color, weight}) => {
                    const rgb = this.hexToRgb(color);
                    r += rgb.r * weight;
                    g += rgb.g * weight;
                    b += rgb.b * weight;
                });
                return `rgba(${Math.round(r)}, ${Math.round(g)}, ${Math.round(b)}, ${intensity})`;
            }
        
            hexToRgb(hex) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                } : {r: 0, g: 0, b: 0};
            }
        
            adjustColorBrightness(rgba, amount) {
                const rgbaMatch = rgba.match(/^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*[\d.]+)?\)$/);
                if (!rgbaMatch) return rgba;
                
                const r = Math.max(0, Math.min(255, parseInt(rgbaMatch[1]) + amount));
                const g = Math.max(0, Math.min(255, parseInt(rgbaMatch[2]) + amount));
                const b = Math.max(0, Math.min(255, parseInt(rgbaMatch[3]) + amount));
                
                return `rgba(${r}, ${g}, ${b}, ${rgba.split(',')[3]?.trim().slice(0, -1) || '1'})`;
            }
        
            applyGravity(particle) {
                const dx = this.x - particle.x;
                const dy = this.y - particle.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < this.radius + particle.radius) {
                    return this.handleCollision(particle, dx, dy, distance);
                }

                if (distance < this.fieldRadius) {
                    this.recentParticles[particle.type] = Math.min(
                        this.maxTypeCount,
                        this.recentParticles[particle.type] + 1
                    );
                }

                const forceMagnitude = (this.gForce * this.mass) / (distance * distance);
                const angle = Math.atan2(dy, dx);
                
                particle.dx += Math.cos(angle) * forceMagnitude;
                particle.dy += Math.sin(angle) * forceMagnitude;
        
                return true;
            }
        
            handleCollision(particle, dx, dy, distance) {
                const angle = Math.atan2(dy, dx);
                const speed = Math.sqrt(particle.dx * particle.dx + particle.dy * particle.dy);

                particle.x = this.x - Math.cos(angle) * (this.radius + particle.radius);
                particle.y = this.y - Math.sin(angle) * (this.radius + particle.radius);

                const energyLoss = 0.5;
                particle.dx = Math.cos(angle) * speed * -energyLoss;
                particle.dy = Math.sin(angle) * speed * -energyLoss;

                const scatter = 0.2;
                particle.dx += (Math.random() - 0.5) * scatter;
                particle.dy += (Math.random() - 0.5) * scatter;
                
                return true;
            }
        
            update() {
                Object.keys(this.recentParticles).forEach(type => {
                    this.recentParticles[type] *= 0.95;
                });
            }
        }
        class Particle {
            constructor(type, x, y) {
                this.type = type;
                this.x = x || Math.random() * WORLD_SIZE.width;
                this.y = y || Math.random() * WORLD_SIZE.height;
                this.radius = type === 'electron' ? 3 : 6;
                this.speed = type === 'electron' ? 3.5 : 2;
                this.dx = (Math.random() - 0.5) * this.speed;
                this.dy = (Math.random() - 0.5) * this.speed;
                this.charge = type === 'proton' ? 1 : type === 'electron' ? -1 : 0;
                this.mass = type === 'electron' ? 1 : 1836;
                this.bonds = new Set();
                this.maxBonds = type === 'electron' ? 2 : type === 'proton' ? 2 : 3;
                this.color = type === 'proton' ? '#B94FFF' :
                    type === 'neutron' ? '#318AFF' : 
                    '#FF4980';
            }

            update(celestialBody) {
                this.handleForces(celestialBody);
                this.updatePosition();
                this.handleBoundaries();
                return true;
            }

            handleForces(celestialBody) {
                let totalForceX = 0;
                let totalForceY = 0;

                particles.forEach(other => {
                    if (other === this) return;

                    const dx = other.x - this.x;
                    const dy = other.y - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < 500) {
                        const force = this.calculateForce(other, distance);
                        totalForceX += Math.cos(Math.atan2(dy, dx)) * force;
                        totalForceY += Math.sin(Math.atan2(dy, dx)) * force;
                        this.tryBond(other, distance);
                    }
                });

                celestialBody.applyGravity(this);

                const dampening = 0.99;
                this.dx = (this.dx + totalForceX / this.mass) * dampening;
                this.dy = (this.dy + totalForceY / this.mass) * dampening;
            }

            calculateForce(other, distance) {
                const coulomb = (this.charge * other.charge) / (distance * distance);
                const nuclear = (this.type !== 'electron' && other.type !== 'electron' && distance < 50) ? 
                            2 * Math.exp(-distance / 15) : 0;
                const repulsion = distance < this.radius + other.radius ? 1 : 0;
                return (coulomb + nuclear - repulsion) * 0.5;
            }

            tryBond(other, distance) {
                const canBond = this.type !== other.type && 
                            this.bonds.size < this.maxBonds && 
                            other.bonds.size < other.maxBonds;
                            
                if (canBond && distance < 60) {
                    this.bonds.add(other);
                    other.bonds.add(this);
                } else if (distance > 120) {
                    this.bonds.delete(other);
                    other.bonds.delete(this);
                }
            }

            updatePosition() {
                if (this.bonds.size > 0) {
                    let centerX = 0, centerY = 0;
                    this.bonds.forEach(bonded => {
                        centerX += bonded.x;
                        centerY += bonded.y;
                    });
                    centerX /= this.bonds.size;
                    centerY /= this.bonds.size;
                    
                    this.x += (centerX - this.x) * 0.1 + this.dx;
                    this.y += (centerY - this.y) * 0.1 + this.dy;
                } else {
                    this.x += this.dx;
                    this.y += this.dy;
                }
            }

            handleBoundaries() {
                if (this.x < this.radius) {
                    this.x = this.radius;
                    this.dx *= -elasticity;
                }
                if (this.x > WORLD_SIZE.width - this.radius) {
                    this.x = WORLD_SIZE.width - this.radius;
                    this.dx *= -elasticity;
                }
                if (this.y < this.radius) {
                    this.y = this.radius;
                    this.dy *= -elasticity;
                }
                if (this.y > WORLD_SIZE.height - this.radius) {
                    this.y = WORLD_SIZE.height - this.radius;
                    this.dy *= -elasticity;
                }
            }

            draw(ctx, scale = 1, isMinMap = false) {
                if (!isMinMap) {
                    const screenX = (this.x - cameraX) * zoom + canvas.width / 2;
                    const screenY = (this.y - cameraY) * zoom + canvas.height / 2;

                    if (screenX < -50 || screenX > canvas.width + 50 || 
                        screenY < -50 || screenY > canvas.height + 50) {
                        return;
                    }

                    ctx.beginPath();
                    ctx.arc(screenX, screenY, this.radius * zoom, 0, Math.PI * 2);
                    ctx.fillStyle = this.color;
                    ctx.fill();

                    this.bonds.forEach(bonded => {
                        const bondedScreenX = (bonded.x - cameraX) * zoom + canvas.width / 2;
                        const bondedScreenY = (bonded.y - cameraY) * zoom + canvas.height / 2;
                        
                    
                    });
                } else {
                    const minimapScaleX = miniMap.width / WORLD_SIZE.width;
                    const minimapScaleY = miniMap.height / WORLD_SIZE.height;
                    
                    ctx.beginPath();
                    ctx.arc(
                        this.x * minimapScaleX,
                        this.y * minimapScaleY,
                        1,
                        0,
                        Math.PI * 2
                    );
                    ctx.fillStyle = this.color;
                    ctx.fill();
                }
            }
        }
                
        function clearCanvas() {
            ctx.fillStyle = 'rgba(0, 0, 0, 1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            miniCtx.fillStyle = '#000';
            miniCtx.fillRect(0, 0, miniMap.width, miniMap.height);
        }

        const celestialBody = new CelestialBody(WORLD_SIZE.width / 2, WORLD_SIZE.height / 2, 5000, 50);

        function update() {
            particles = particles.filter(particle => {
                if (showCelestialBody) {
                    return particle.update(celestialBody);
                } else {
                    particle.handleForces({
                        applyGravity: () => {} 
                    });
                    particle.updatePosition();
                    particle.handleBoundaries();
                    return true;
                }
            });
        }

        function draw() {
            clearCanvas();
            
            if (showCelestialBody) {
                celestialBody.draw(ctx, zoom, cameraX, cameraY, canvas.width, canvas.height);
            }
            
            particles.forEach(particle => particle.draw(ctx));
            
            if (showMinimap) {
                const minimapScaleX = miniMap.width / WORLD_SIZE.width;
                const minimapScaleY = miniMap.height / WORLD_SIZE.height;
                
                particles.forEach(particle => particle.draw(miniCtx, 1, true));
                
                const viewportRect = {
                    x: (cameraX - canvas.width / (2 * zoom)) * minimapScaleX,
                    y: (cameraY - canvas.height / (2 * zoom)) * minimapScaleY,
                    width: (canvas.width / zoom) * minimapScaleX,
                    height: (canvas.height / zoom) * minimapScaleY
                };
                
                miniCtx.strokeStyle = '#fff';
                miniCtx.strokeRect(
                    viewportRect.x,
                    viewportRect.y,
                    viewportRect.width,
                    viewportRect.height
                );
            }
        }
        function gameLoop(timestamp) {
            if (!lastUpdateTime) lastUpdateTime = timestamp;
            const elapsed = timestamp - lastUpdateTime;

            if (elapsed > 16) {
                updateCamera();
                update();
                draw();
                lastUpdateTime = timestamp;
            }

            if (isAnimating) {
                requestAnimationFrame(gameLoop);
            }
        }
        ['proton', 'neutron', 'electron'].forEach(type => {
            document.getElementById(`add${type.charAt(0).toUpperCase() + type.slice(1)}`).addEventListener('click', () => {
                for (let i = 0; i < 10; i++) {
                    const x = cameraX + (Math.random() - 0.5) * canvas.width / zoom;
                    const y = cameraY + (Math.random() - 0.5) * canvas.height / zoom;
                    particles.push(new Particle(type, x, y));
                }
            });
        });

        document.getElementById('toggleAnimation').addEventListener('click', e => {
            isAnimating = !isAnimating;
            
            const button = e.target.closest('.action-button');
            if (!button) return;
            
            if (isAnimating) {
                button.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" height="20px" viewBox="0 -960 960 960" width="24px" fill="currentColor">
                        <path d="M520-200h80v-560h-80v560Zm-160 0h80v-560h-80v560Z"/>
                    </svg>`;
                lastUpdateTime = 0;
                requestAnimationFrame(gameLoop);
            } else {
                button.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" height="20px" viewBox="0 -960 960 960" width="24px" fill="currentColor">
                        <path d="M320-200v-560l440 280-440 280Z"/>
                    </svg>`;
            }
            
            button.classList.toggle('start-button');
            button.classList.toggle('clear-button');
        });

        document.getElementById('clearCanvas').addEventListener('click', () => {
            particles = [];
        });

        window.addEventListener('keydown', (e) => {
            keys.add(e.key);
          
            if (e.code === 'Space') {
                e.preventDefault();
                document.getElementById('toggleAnimation').click();
            }
           
            if (e.key === 'Shift') {
                isPanning = true;
                canvas.style.cursor = 'grab';
            }
        });

        window.addEventListener('keyup', (e) => {
            keys.delete(e.key);
            if (e.key === 'Shift') {
                isPanning = false;
                canvas.style.cursor = 'default';
            }
        });

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
          
            const factor = e.deltaY > 0 ? 0.9 : 1.1;
            zoomToPoint(mouseX, mouseY, factor);
        });

        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            lastX = e.clientX - rect.left;
            lastY = e.clientY - rect.top;
            
            if (e.button === 0) {
                if (isPanning || e.shiftKey) {
                    isDragging = true;
                    canvas.style.cursor = 'grabbing';
                } else {
                    isMouseDown = true;
                    const worldX = cameraX + (lastX - canvas.width / 2) / zoom;
                    const worldY = cameraY + (lastY - canvas.height / 2) / zoom;
                    particles.push(new Particle('proton', worldX, worldY));
                }
            } else if (e.button === 2) {
                isRightMouseDown = true;
                const worldX = cameraX + (lastX - canvas.width / 2) / zoom;
                const worldY = cameraY + (lastY - canvas.height / 2) / zoom;
                particles.push(new Particle('electron', worldX, worldY));
            } else if (e.button === 1) {
                e.preventDefault();
                isDragging = true;
                canvas.style.cursor = 'grabbing';
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            if (isDragging) {
                const dx = (mouseX - lastX) / zoom;
                const dy = (mouseY - lastY) / zoom;
                cameraX -= dx;
                cameraY -= dy;
                checkBoundaries();
                lastX = mouseX;
                lastY = mouseY;
            }
            
            if (isMouseDown || isRightMouseDown) {
                const worldX = cameraX + (mouseX - canvas.width / 2) / zoom;
                const worldY = cameraY + (mouseY - canvas.height / 2) / zoom;
                
                if (Math.random() < 0.3) {
                    if (isMouseDown) {
                        particles.push(new Particle('proton', worldX, worldY));
                    }
                    if (isRightMouseDown) {
                        particles.push(new Particle('electron', worldX, worldY));
                    }
                }
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            if (e.button === 0) {
                isMouseDown = false;
                if (isDragging) {
                    isDragging = false;
                    canvas.style.cursor = isPanning ? 'grab' : 'default';
                }
            }
            if (e.button === 2) isRightMouseDown = false;
            if (e.button === 1) {
                e.preventDefault();
                isDragging = false;
                canvas.style.cursor = isPanning ? 'grab' : 'default';
            }
        });

       
        canvas.addEventListener('dblclick', (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            const worldX = cameraX + (mouseX - canvas.width / 2) / zoom;
            const worldY = cameraY + (mouseY - canvas.height / 2) / zoom;
            
            cameraX = worldX;
            cameraY = worldY;
            targetZoom = 2;
            checkBoundaries();
        });

     
        let touchStartDistance = 0;
        
        canvas.addEventListener('touchstart', (e) => {
            if (e.touches.length === 2) {
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                touchStartDistance = Math.sqrt(dx * dx + dy * dy);
            }
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (e.touches.length === 2) {
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                const centerX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
                const centerY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
                
                const factor = distance / touchStartDistance;
                zoomToPoint(centerX, centerY, factor);
                touchStartDistance = distance;
            }
        });
        canvas.addEventListener('mouseleave', () => {
            isMouseDown = false;
            isRightMouseDown = false;
            isDragging = false;
        });

        canvas.addEventListener('contextmenu', (e) => e.preventDefault());

        window.addEventListener('blur', () => {
            isMouseDown = false;
            isRightMouseDown = false;
            isDragging = false;
        });

        document.getElementById('toggleCelestialBody').addEventListener('click', (e) => {
            showCelestialBody = !showCelestialBody;
            
            const button = e.target.closest('.celestial-toggle-button');
            if (!button) return;
           
            button.classList.toggle('disabled');
            
            const svg = button.querySelector('svg');
            if (svg) {
                svg.style.color = showCelestialBody ? 'white' : '#666';
            }
            
            if (!showCelestialBody) {
                particles.forEach(particle => {
                    particle.dx *= 1.5;
                    particle.dy *= 1.5;
                });
            }
        });

        document.getElementById('toggleMinimap').addEventListener('click', (e) => {
            showMinimap = !showMinimap;
            
            const button = e.target.closest('.minimap-toggle-button');
            if (!button) return;
            
            button.classList.toggle('disabled');
            
            const svg = button.querySelector('svg');
            if (svg) {
                svg.style.color = showMinimap ? 'white' : '#666';
            }
            
            const miniMap = document.getElementById('miniMap');
            miniMap.classList.toggle('hidden');
        });

        window.addEventListener('resize', resizeCanvas);

        resizeCanvas();
        
        ['proton', 'neutron', 'electron'].forEach(type => {
            for (let i = 0; i < 300; i++) {
                particles.push(new Particle(type));
            }
        });

        isAnimating = true;
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>